#include <stdio.h>
#include <stdlib.h>
#include "Parser.h"
#include <math.h>
typedef struct node node;//This is to avoid having to type struct node all 
//the time. I could have defined it to be a pointer but it would make the 
//code less readable.
struct node{
  node* leftNode;
  node* rightNode;
//This union is used to store the content of a node. For a leaf node, that is
//a number and for other nodes, that is an operator.
  union{
    double operand;
    char operator;
  }contents;
  enum{
    leaf,
    branch
  }type;
};

void insertOperator(node* node,char operator);
node* createEmptyNode();
void insertOperand(node* node,double operand);
double proccessNode(node* node);
int precedence(char operator);
//Takes a pointer to an empty node and an operator and assigns the 
//operator to the contents union of the node.
void insertOperator(node* node,char operator){
  node->contents.operator=operator;
  node->type=branch;
if(node->leftNode==NULL)
    node->leftNode=createEmptyNode();
  if(node->rightNode==NULL)
    node->rightNode=createEmptyNode();
}
//Returns a pointer to a an empty node on the heap with both of its children null and the contents unititialized.
node* createEmptyNode(){
  node* retval=malloc(sizeof(node));
  retval->rightNode=NULL;
  retval->leftNode=NULL;
  return retval;
}
//Takes a pointer to an empty node and a double and assigns the double to the
//content of the node.
void insertOperand(node* node,double operand){
  node->contents.operand=operand;
  node->type=leaf;
}
//Takes an operator and returns its precedence in terms of order of operations.
//A higher return value means that the operator should be done earlier.
int precedence(char operator){
  switch(operator){
  case '*':  //Falls through to '/'
  case '/':
    return 2;
    break;
  case '^':
    return 3;
    break;
  case '+':
  case '-':
  default:
    return 1;
    break;

  }
}
//Declare references to the root node and the node that is furthest to the 
//right.  This points to the location where the next operand should be placed.
node* rootNode;
node* rightNode;

int main(int nArgs,char** args){
  initialize(*(args+1));//Initialize the parser to the first argument.
  //Initialize the rootNode and rightNode to be the right child of the root
  //node.
  rootNode=createEmptyNode();
  //Initialize the children of rootNode and process the first two parameters (the first operand and the first operator).  The root node should contain the operator and its left child should contain the operand.
  rootNode->leftNode=createEmptyNode();
  insertOperand(rootNode->leftNode,nextDouble());
  insertOperator(rootNode,nextChar());
  rootNode->rightNode=createEmptyNode();
  rightNode=rootNode->rightNode;
  char prevOperator=rootNode->contents.operator;
  //For every operand and operator, add a node for the operator and a child of that for the ooerand.
  while(1){
    double operand=nextDouble();
    //If the operand is the last one then assign it to rightNode, which is kept blank in the previous iterations of the loop and break.
    if(endOfBuffer()){
      insertOperand(rightNode,operand);
      break;
    }
    
    char operator=nextChar();
    node* tempRoot=createEmptyNode();
    tempRoot->type=branch;
    tempRoot->rightNode=rootNode;
    node* pNode=tempRoot;
    //This loop runs until pNode is the parent node of the uppermost node
    //whose operator is of equal of lower precedence to the operator to add.
    //In other words, pNode will be the last node that should be higher on
    //the tree (in other words, with lower precedence) than the operator to
    //add.
    while(pNode->rightNode->type==branch &&
	 precedence(operator)>precedence(pNode->rightNode->contents.operator))
      pNode=pNode->rightNode;
    
    node* toInsert=createEmptyNode();
    insertOperator(toInsert,operator);
    if(precedence(operator)>precedence(prevOperator)){      
      insertOperand(toInsert->leftNode,operand);
    }else{
      insertOperand(rightNode,operand);
      toInsert->leftNode=pNode->rightNode;
    }
    pNode->rightNode=toInsert;
    rightNode=toInsert->rightNode;
    prevOperator=operator;
    if(pNode==tempRoot)
      rootNode=toInsert;
    free(tempRoot);
  }
  double result=proccessNode(rootNode);
  printf("The result of the calculation is %f\n",result);
  return 0;
}
//This function proccesses a node. If it is a leaf node, it returns its
//content. If it is a branch node, it returns the operator it represents
//performed on its two children. It also realeases the memory used by the
//node in the heap.
double proccessNode(node* node){
  double retval;
  double divisor;
  switch(node->type){
  case leaf:
    retval=node->contents.operand;
    break;
  case branch:
    switch(node->contents.operator){
    case '+':
      retval=proccessNode(node->leftNode)+proccessNode(node->rightNode);
      break;
    case '-':
      retval=proccessNode(node->leftNode)-proccessNode(node->rightNode);
      break;
    case '*':
      retval=proccessNode(node->leftNode)*proccessNode(node->rightNode);
      break;
    case '/':
      //Check for division by zero.
      divisor=proccessNode(node->rightNode);
      if(divisor==0)
	(void)printf("Division by zero error");
      retval=proccessNode(node->leftNode)/divisor;
      break;
    case '^':
      retval=pow(proccessNode(node->leftNode),proccessNode(node->rightNode));
    }
  }
  free(node);
 return retval;
}
